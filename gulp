loadstring(game:HttpGet("https://raw.githubusercontent.com/CrimsonsMoons/studlands/refs/heads/main/gg", true))()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Keybinds (customizable here)
local Keybinds = {
    Lock = Enum.KeyCode.R,
    Destroy = Enum.KeyCode.L,
    Mode = Enum.KeyCode.M,
    Stomp = Enum.KeyCode.K,
    ToggleGUI = Enum.KeyCode.O,
    ToggleESP = Enum.KeyCode.P,
    TogglePrediction = Enum.KeyCode.J,
    ToggleKeybindsGUI = Enum.KeyCode.U,
}

-- Variables
local lockedUserId = nil
local lockedPlayer = nil
local locking = false
local killed = false
local lockModeHard = true -- true = Mode 1 (hard lock), false = Mode 2 (square teleport)
local stompEnabled = false

local guiEnabled = true
local espEnabled = true
local resolverMode = true -- true = resolver ON (advanced), false = OFF (normal prediction)

local connections = {}

local teleportDistance = 15  -- distance from target
local teleportHeight = 10    -- height above target
local teleportSpeed = 4      -- squares per second

local teleportPositions = {}
local currentPosIndex = 1
local elapsedTime = 0

local lastPositions = {}
local lastTimes = {}
local lastPredictedPosition = nil

local function updateTeleportPositions()
    local d = teleportDistance
    teleportPositions = {
        Vector3.new(d, teleportHeight, d),
        Vector3.new(-d, teleportHeight, d),
        Vector3.new(-d, teleportHeight, -d),
        Vector3.new(d, teleportHeight, -d),
    }
end
updateTeleportPositions()

local function getHumanoidRootPart(character)
    return character and character:FindFirstChild("HumanoidRootPart")
end

local function getUpperTorso(character)
    return character and character:FindFirstChild("UpperTorso")
end

local function isKnocked(player)
    local playersFolder = workspace:FindFirstChild("Players")
    if not playersFolder then return false end
    local playerModel = playersFolder:FindFirstChild(player.Name)
    if not playerModel then return false end
    local bd = playerModel:FindFirstChild("BD")
    if not bd then return false end
    local knocked = bd:FindFirstChild("Knocked")
    return knocked and knocked.Value == true
end

local function getPredictionTime(part)
    if not part then return 0.15 end
    if resolverMode then
        local size = part.Size.Magnitude
        local baseTime = size * 0.05
        local extraPrediction = 0.1
        return math.clamp(baseTime + extraPrediction, 0.1, 0.5)
    else
        return 0.2 -- fixed prediction time for normal mode
    end
end

local function teleportCharacter(pos)
    local char = LocalPlayer.Character
    if char then
        local hrp = getHumanoidRootPart(char)
        if hrp then
            hrp.CFrame = CFrame.new(pos)
        end
    end
end

local stompRemote = ReplicatedStorage:WaitForChild("assets", 9e9)
    :WaitForChild("dh", 9e9)
    :WaitForChild("MainEvent", 9e9)

local stompArgs = {"Stomp"}

-- GUI Creation
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AdvancedLockGui"
screenGui.ResetOnSpawn = false
screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local infoFrame = Instance.new("Frame", screenGui)
infoFrame.Size = UDim2.new(0, 280, 0, 180)
infoFrame.Position = UDim2.new(0, 10, 1, -190)
infoFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
infoFrame.BackgroundTransparency = 0.2

local function makeLabel(parent, order)
    local lbl = Instance.new("TextLabel", parent)
    lbl.BackgroundTransparency = 1
    lbl.Size = UDim2.new(1, -60, 0, 20)
    lbl.Position = UDim2.new(0, 0, 0, (order - 1) * 22)
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 16
    lbl.TextColor3 = Color3.new(1, 1, 1)
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    return lbl
end

local nameLabel = makeLabel(infoFrame, 1)
local distanceLabel = makeLabel(infoFrame, 2)
local knockedLabel = makeLabel(infoFrame, 3)
local healthLabel = makeLabel(infoFrame, 4)
local modeLabel = makeLabel(infoFrame, 5)
local stompLabel = makeLabel(infoFrame, 6)
local predictionLabel = makeLabel(infoFrame, 7)
local accountAgeLabel = makeLabel(infoFrame, 8)


local profilePic = Instance.new("ImageLabel", infoFrame)
profilePic.Size = UDim2.new(0, 48, 0, 48)
profilePic.Position = UDim2.new(1, -52, 0, 20)
profilePic.BackgroundTransparency = 1
profilePic.Image = ""

-- Selection boxes & billboard variables
local selectionBoxes = {}

local function clearSelectionBoxes()
    for _, box in pairs(selectionBoxes) do
        if box and box.Parent then
            box:Destroy()
        end
    end
    selectionBoxes = {}
end

local function createSelectionBoxes(character, color)
    clearSelectionBoxes()
    if character and character:IsA("Model") then
        for _, part in pairs(character:GetChildren()) do
            if part:IsA("BasePart") then
                local box = Instance.new("SelectionBox")
                box.Adornee = part
                box.LineThickness = 0.05
                box.Color3 = color
                box.SurfaceTransparency = 0.75
                box.Parent = part
                table.insert(selectionBoxes, box)
            end
        end
    end
end

local billboardGui = nil
local billboardText = nil

local function createBillboard(character)
    if billboardGui then
        billboardGui:Destroy()
        billboardGui = nil
        billboardText = nil
    end

    if not character or not character:IsA("Model") then return end

    local head = character:FindFirstChild("Head")
    if not head or not head:IsA("BasePart") then return end

    billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "TargetNameBillboard"
    billboardGui.Adornee = head
    billboardGui.Size = UDim2.new(0, 100, 0, 35)
    billboardGui.StudsOffset = Vector3.new(0, 2.5, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.Parent = head

    billboardText = Instance.new("TextLabel")
    billboardText.Size = UDim2.new(1, 0, 1, 0)
    billboardText.BackgroundTransparency = 1
    billboardText.Text = ""
    billboardText.Font = Enum.Font.GothamBold
    billboardText.TextSize = 20
    billboardText.TextColor3 = Color3.new(1, 1, 1)
    billboardText.TextStrokeTransparency = 0.5
    billboardText.Parent = billboardGui
end

local function setBillboardText(text)
    if billboardText then
        billboardText.Text = text
    end
end

local function destroyBillboard()
    if billboardGui then
        billboardGui:Destroy()
        billboardGui = nil
        billboardText = nil
    end
end

local function getRainbowColor(time)
    local frequency = 2
    local r = math.sin(frequency * time + 0) * 0.5 + 0.5
    local g = math.sin(frequency * time + 2) * 0.5 + 0.5
    local b = math.sin(frequency * time + 4) * 0.5 + 0.5
    return Color3.new(r, g, b)
end

local function getPredictedPosition(part, dt)
    if not part then return nil end

    local currentPos = part.Position
    local currentTime = tick()

    if resolverMode then
        table.insert(lastPositions, currentPos)
        table.insert(lastTimes, currentTime)
        if #lastPositions > 2 then
            table.remove(lastPositions, 1)
            table.remove(lastTimes, 1)
        end

        if #lastPositions < 2 then
            return currentPos
        end

        local pos1, pos2 = lastPositions[1], lastPositions[2]
        local time1, time2 = lastTimes[1], lastTimes[2]
        local deltaTime = time2 - time1
        if deltaTime <= 0 then
            return currentPos
        end

        local velocity = (pos2 - pos1) / deltaTime
        local predictionTime = getPredictionTime(part)
        local predictedPos = currentPos + velocity * predictionTime

        if lastPredictedPosition then
            local smoothFactor = 0.5
            predictedPos = predictedPos:Lerp(lastPredictedPosition, smoothFactor)
        end

        lastPredictedPosition = predictedPos
        return predictedPos

    else
        local velocity = part.Velocity
        local predictionTime = 0.2
        local predictedPos = currentPos + velocity * predictionTime
        lastPredictedPosition = predictedPos
        return predictedPos
    end
end

-- GUI visibility helpers to prevent disappearing
local function hideGui()
    if infoFrame then
        infoFrame.Visible = false
    end
    guiEnabled = false
end

local function showGui()
    if infoFrame then
        infoFrame.Visible = true
    end
    guiEnabled = true
end

-- Input handling
table.insert(connections, UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType ~= Enum.UserInputType.Keyboard then return end

    if input.KeyCode == Keybinds.Lock then
        if locking then
            locking = false
            lockedUserId = nil
            lockedPlayer = nil
            lastPositions = {}
            lastTimes = {}
            lastPredictedPosition = nil
            hideGui()
            setupESP(nil)
            print("Camera unlocked")
        else
            local mousePos = UserInputService:GetMouseLocation()
            local closestPlayer = nil
            local closestDist = 250

            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    local char = player.Character
                    if char then
                        local upperTorso = getUpperTorso(char)
                        local hrp = getHumanoidRootPart(char)
                        local targetPart = upperTorso or hrp
                        local humanoid = char:FindFirstChildOfClass("Humanoid")
                        if targetPart and humanoid and humanoid.Health > 0 and not isKnocked(player) then
                            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                            if onScreen then
                                local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                                if dist < closestDist then
                                    closestDist = dist
                                    closestPlayer = player
                                end
                            end
                        end
                    end
                end
            end

            if closestPlayer then
                lockedUserId = closestPlayer.UserId
                lockedPlayer = closestPlayer
                locking = true
                killed = false
                elapsedTime = 0
                currentPosIndex = 1
                lastPositions = {}
                lastTimes = {}
                lastPredictedPosition = nil
                showGui()
                print("Locked onto:", lockedPlayer.Name)
            else
                print("No valid target found in FOV")
                locking = false
                lockedUserId = nil
                lockedPlayer = nil
                hideGui()
                setupESP(nil)
            end
        end

    elseif input.KeyCode == Keybinds.Mode then
        lockModeHard = not lockModeHard
        print("Lock mode switched to", lockModeHard and "Hard (instant)" or "Square Teleport")

    elseif input.KeyCode == Keybinds.Stomp then
        stompEnabled = not stompEnabled
        print("Stomp mode", stompEnabled and "enabled" or "disabled")

    elseif input.KeyCode == Keybinds.Destroy then
        print("Destroy key pressed - cleaning up script...")

        locking = false
        killed = true
        lockedUserId = nil
        lockedPlayer = nil
        stompEnabled = false
        hideGui()
        setupESP(nil)
        destroyBillboard()

        for _, con in pairs(connections) do
            con:Disconnect()
        end
        connections = {}

        screenGui:Destroy()
        clearSelectionBoxes()

        if keybindsGui then
            keybindsGui:Destroy()
        end

        print("Script destroyed.")
    elseif input.KeyCode == Keybinds.ToggleGUI then
        guiEnabled = not guiEnabled
        if guiEnabled then
            showGui()
        else
            hideGui()
        end

    elseif input.KeyCode == Keybinds.ToggleESP then
        espEnabled = not espEnabled
        if not espEnabled then
            clearSelectionBoxes()
            destroyBillboard()
        end

    elseif input.KeyCode == Keybinds.TogglePrediction then
        resolverMode = not resolverMode
        print("Resolver mode is now:", resolverMode and "ON" or "OFF")

    elseif input.KeyCode == Keybinds.ToggleKeybindsGUI then
        toggleKeybindsGUI()
    end
end))

local function setupESP(character)
    if espEnabled and character and character:IsA("Model") and character.Parent == workspace then
        local color = getRainbowColor(tick())
        createSelectionBoxes(character, color)
        createBillboard(character)
    else
        clearSelectionBoxes()
        destroyBillboard()
    end
end

table.insert(connections, RunService.RenderStepped:Connect(function(dt)
    if killed or not locking or not lockedUserId then
        setupESP(nil)
        return
    end

    if not lockedPlayer or not lockedPlayer.Parent then
        lockedPlayer = nil
        for _, p in pairs(Players:GetPlayers()) do
            if p.UserId == lockedUserId then
                lockedPlayer = p
                print("Reacquired player:", p.Name)
                break
            end
        end
    end

    if not lockedPlayer or not lockedPlayer.Character then
        hideGui()
        setupESP(nil)
        return
    end

    local player = lockedPlayer
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    local hrp = getHumanoidRootPart(player.Character)
    local upperTorso = getUpperTorso(player.Character)

    local targetPart = upperTorso or hrp
    if not targetPart then
        hideGui()
        setupESP(nil)
        return
    end

    -- Use prediction function (resolver or normal)
    local predictedPos = getPredictedPosition(targetPart, dt)
    local camPos = Camera.CFrame.Position

    if lockModeHard then
        Camera.CFrame = CFrame.new(camPos, predictedPos)
    else
        elapsedTime = elapsedTime + dt
        local interval = 1 / teleportSpeed
        if elapsedTime >= interval then
            elapsedTime = elapsedTime - interval
            currentPosIndex = currentPosIndex + 1
            if currentPosIndex > #teleportPositions then
                currentPosIndex = 1
            end
        end

-- 🟨 Replace this block in your RenderStepped function:

-- local teleportPos = predictedPos + teleportPositions[currentPosIndex]

-- With this:

local isAirborne = humanoid and humanoid.FloorMaterial == Enum.Material.Air
local verticalOffset = isAirborne and Vector3.new(0, 2.5, 0) or Vector3.new(0, 0.5, 0)
local dynamicDistance = isAirborne and (teleportDistance * 0.65) or teleportDistance
local dynamicHeight = isAirborne and (teleportHeight * 0.75) or teleportHeight

-- Update teleport pattern for current state (air or ground)
teleportPositions = {
    Vector3.new(dynamicDistance, dynamicHeight, dynamicDistance),
    Vector3.new(-dynamicDistance, dynamicHeight, dynamicDistance),
    Vector3.new(-dynamicDistance, dynamicHeight, -dynamicDistance),
    Vector3.new(dynamicDistance, dynamicHeight, -dynamicDistance),
}

-- Update square teleport index
elapsedTime = elapsedTime + dt
local interval = 1 / teleportSpeed
if elapsedTime >= interval then
    elapsedTime = elapsedTime - interval
    currentPosIndex = currentPosIndex + 1
    if currentPosIndex > #teleportPositions then
        currentPosIndex = 1
    end
end

-- Final teleport position, with dynamic offset
local teleportPos = predictedPos + teleportPositions[currentPosIndex] + verticalOffset

if not (stompEnabled and isKnocked(player)) then
    teleportCharacter(teleportPos)
end

-- Always look at the center of mass
Camera.CFrame = CFrame.new(camPos, predictedPos + verticalOffset)

        if not (stompEnabled and isKnocked(player)) then
            teleportCharacter(teleportPos)
        end

        Camera.CFrame = CFrame.new(camPos, predictedPos)
    end

    if stompEnabled and isKnocked(player) and upperTorso then
        teleportCharacter(upperTorso.Position + Vector3.new(0, 3, 0))
        pcall(function()
            stompRemote:FireServer(unpack(stompArgs))
        end)
    end

    if humanoid then
        local dist = (camPos - targetPart.Position).Magnitude
        nameLabel.Text = "Name: " .. player.Name
        distanceLabel.Text = string.format("Distance: %.1f studs", dist)
        knockedLabel.Text = "Knocked: " .. tostring(isKnocked(player))
        healthLabel.Text = "Health: " .. math.floor(humanoid.Health)
        modeLabel.Text = "Lock Mode: " .. (lockModeHard and "Hard (instant)" or "Square Teleport")
        stompLabel.Text = "Stomp Mode: " .. (stompEnabled and "ON" or "OFF")
        predictionLabel.Text = "Resolver: " .. (resolverMode and "ON" or "OFF")
        accountAgeLabel.Text = "Account Age: " .. tostring(player.AccountAge) .. " days"
        profilePic.Image = "https://www.roblox.com/headshot-thumbnail/image?userId="..player.UserId.."&width=150&height=150&format=png"
        showGui()
    else
        hideGui()
    end

    local time = tick()
    local rainbowColor = getRainbowColor(time)

    if player.Character then
        createSelectionBoxes(player.Character, rainbowColor)
    else
        clearSelectionBoxes()
    end

    if billboardText then
        billboardText.TextColor3 = rainbowColor
        setBillboardText(player.Name)
    elseif player.Character then
        createBillboard(player.Character)
    end
end))

-- Keybinds GUI

local keybindsGui = Instance.new("ScreenGui")
keybindsGui.Name = "KeybindsGui"
keybindsGui.ResetOnSpawn = false
keybindsGui.Enabled = false
keybindsGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local keybindsFrame = Instance.new("Frame", keybindsGui)
keybindsFrame.Size = UDim2.new(0, 230, 0, 210)
keybindsFrame.Position = UDim2.new(1, -270, 0, 10)
keybindsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
keybindsFrame.BackgroundTransparency = 0.1
keybindsFrame.BorderSizePixel = 0

local function makeKeybindLabel(parent, text, yPos)
    local lbl = Instance.new("TextLabel", parent)
    lbl.Size = UDim2.new(1, -20, 0, 20)
    lbl.Position = UDim2.new(0, 10, 0, yPos)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 16
    lbl.TextColor3 = Color3.new(1, 1, 1)
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Text = text
    return lbl
end

makeKeybindLabel(keybindsFrame, "R - Lock / Unlock Target", 5)
makeKeybindLabel(keybindsFrame, "M - Switch Lock Mode", 30)
makeKeybindLabel(keybindsFrame, "K - Toggle Stomp", 55)
makeKeybindLabel(keybindsFrame, "L - Destroy Script", 80)
makeKeybindLabel(keybindsFrame, "J - Toggle Resolver Prediction", 105)
makeKeybindLabel(keybindsFrame, "O - Toggle Info GUI", 130)
makeKeybindLabel(keybindsFrame, "P - Toggle ESP", 155)
makeKeybindLabel(keybindsFrame, "U - Toggle Keybinds GUI", 180)

local function toggleKeybindsGUI()
    keybindsGui.Enabled = not keybindsGui.Enabled
end

-- Reparent GUI on respawn to prevent disappearing
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if screenGui and screenGui.Parent ~= LocalPlayer:FindFirstChild("PlayerGui") then
        screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    if keybindsGui and keybindsGui.Parent ~= LocalPlayer:FindFirstChild("PlayerGui") then
        keybindsGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
end)

-- Add new keybind to Keybinds table
Keybinds.BuyArmor = Enum.KeyCode.N

-- Function to auto-buy full armor and return to original spot
local function autoBuyFullArmor()
    local character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart")

    local armorObj = workspace:WaitForChild("Ignored"):WaitForChild("Shop"):WaitForChild("Full Armor")
    local clickDetector = armorObj:FindFirstChildOfClass("ClickDetector")
    if not clickDetector then
        warn("❌ ClickDetector not found in Full Armor model")
        return
    end

    local targetCFrame
    if armorObj:IsA("BasePart") then
        targetCFrame = armorObj.CFrame
    elseif armorObj:IsA("Model") then
        if not armorObj.PrimaryPart then
            armorObj.PrimaryPart = armorObj:FindFirstChildWhichIsA("BasePart")
        end
        if armorObj.PrimaryPart then
            targetCFrame = armorObj.PrimaryPart.CFrame
        else
            warn("❌ No valid part in Full Armor model")
            return
        end
    end

    -- Save original position
    local originalCFrame = hrp.CFrame

    -- Teleport near the shop
    hrp.CFrame = targetCFrame + Vector3.new(0, 2, 0)
    task.wait(0.4) -- Give time for collision settle

    fireclickdetector(clickDetector)

    -- Wait until armor is confirmed (optional: check tool or stat)
    task.wait(0.3)

    -- Return to original position
    hrp.CFrame = originalCFrame
end

-- Add keybind to existing input listener
table.insert(connections, UserInputService.InputBegan:Connect(function(input, processed)
    if processed or input.UserInputType ~= Enum.UserInputType.Keyboard then return end

    if input.KeyCode == Keybinds.BuyArmor then
        autoBuyFullArmor()
    end
end))


local ESP_ENABLED = false
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local espCache = {}
local rainbowLabels = {} -- [player] = {nameLabel = ..., hpLabel = ...}

-- Rainbow color updater
RunService.RenderStepped:Connect(function()
    if not ESP_ENABLED then return end

    local t = tick() * 0.5
    local color = Color3.fromHSV(t % 1, 1, 1)

    for player, labels in pairs(rainbowLabels) do
        if labels then
            if labels.nameLabel and labels.nameLabel.Parent then
                labels.nameLabel.TextColor3 = color
            end
            if labels.hpLabel and labels.hpLabel.Parent then
                labels.hpLabel.TextColor3 = color

                local humanoid = player.Character and player.Character:FindFirstChildWhichIsA("Humanoid")
                if humanoid then
                    labels.hpLabel.Text = "HP: " .. math.floor(humanoid.Health)
                else
                    labels.hpLabel.Text = "HP: ???"
                end
            end
        end
    end
end)

-- Create or update ESP for a player
local function createOrUpdateESP(player)
    if player == LocalPlayer then return end
    local character = player.Character
    if not character then return end

    local head = character:FindFirstChild("Head")
    if not head or not head:IsA("BasePart") then return end

    local existing = espCache[player]
    if existing and existing.Parent == head then return end

    if existing then
        existing:Destroy()
        rainbowLabels[player] = nil
    end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "PlayerESP"
    billboard.Adornee = head
    billboard.Size = UDim2.new(0, 100, 0, 50)
    billboard.StudsOffset = Vector3.new(0, 2.5, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = head

    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.Name
    nameLabel.Font = Enum.Font.SourceSans
    nameLabel.TextSize = 14
    nameLabel.TextStrokeTransparency = 0.5
    nameLabel.TextXAlignment = Enum.TextXAlignment.Center
    nameLabel.TextYAlignment = Enum.TextYAlignment.Center
    nameLabel.Parent = billboard

    local hpLabel = Instance.new("TextLabel")
    hpLabel.Size = UDim2.new(1, 0, 0.5, 0)
    hpLabel.Position = UDim2.new(0, 0, 0.5, 0)
    hpLabel.BackgroundTransparency = 1
    hpLabel.Text = "HP: ???"
    hpLabel.Font = Enum.Font.SourceSans
    hpLabel.TextSize = 14
    hpLabel.TextStrokeTransparency = 0.5
    hpLabel.TextXAlignment = Enum.TextXAlignment.Center
    hpLabel.TextYAlignment = Enum.TextYAlignment.Center
    hpLabel.Parent = billboard

    espCache[player] = billboard
    rainbowLabels[player] = {
        nameLabel = nameLabel,
        hpLabel = hpLabel
    }
end

-- Remove all ESPs
local function clearAllESP()
    for _, gui in pairs(espCache) do
        if gui then gui:Destroy() end
    end
    espCache = {}
    rainbowLabels = {}
end

-- Constantly refresh ESP on visible players
RunService.RenderStepped:Connect(function()
    if not ESP_ENABLED then return end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            createOrUpdateESP(player)
        end
    end
end)

-- Detect when characters respawn
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function()
        if ESP_ENABLED then
            createOrUpdateESP(player)
        end
    end)
end)

-- Input toggle
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.U then
        ESP_ENABLED = not ESP_ENABLED
        print("ESP:", ESP_ENABLED and "ENABLED" or "DISABLED")
        if not ESP_ENABLED then
            clearAllESP()
        else
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    createOrUpdateESP(player)
                end
            end
        end
    end
end)

-- Track already present players
for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function()
            if ESP_ENABLED then
                createOrUpdateESP(player)
            end
        end)
    end
end


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

local antiLockEnabled = false
local anchorModel = nil
local teleportLoop = nil
local noclipConnection
local bodyVelocity

local moveSpeed = 230 -- studs per second
local keysPressed = {}

-- Track keys pressed for movement
UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		keysPressed[input.KeyCode] = true
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.Keyboard then
		keysPressed[input.KeyCode] = false
	end
end)

local function setNoclip(state)
	if noclipConnection then
		noclipConnection:Disconnect()
		noclipConnection = nil
	end
	if state then
		noclipConnection = RunService.Stepped:Connect(function()
			if LocalPlayer.Character then
				for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
					if part:IsA("BasePart") then
						part.CanCollide = false
					end
				end
			end
		end)
	end
end

-- Create the anchor model with a humanoid and a head-sized purple box with forcefield
local function createAnchorModel(position)
	-- Clean old
	if anchorModel then
		anchorModel:Destroy()
		anchorModel = nil
	end

	local model = Instance.new("Model")
	model.Name = "AntiLockBox"
	model.Parent = Workspace

	local headPart = Instance.new("Part")
	headPart.Name = "Head"
	headPart.Size = Vector3.new(2, 1, 1) -- Roblox head approx size
	headPart.Position = position + Vector3.new(0, 2.5, 0) -- slight offset to avoid ground clipping
	headPart.Anchored = false
	headPart.CanCollide = true
	headPart.BrickColor = BrickColor.new("Royal purple")
	headPart.Transparency = 0.5
	headPart.Material = Enum.Material.Neon
	headPart.Parent = model

	local ff = Instance.new("ForceField")
	ff.Visible = true
	ff.Parent = headPart

	local hrp = Instance.new("Part")
	hrp.Name = "HumanoidRootPart"
	hrp.Size = Vector3.new(2, 2, 1)
	hrp.Position = position
	hrp.Transparency = 1
	hrp.CanCollide = false
	hrp.Anchored = false
	hrp.Parent = model

	local weld = Instance.new("WeldConstraint")
	weld.Part0 = headPart
	weld.Part1 = hrp
	weld.Parent = headPart

	local humanoid = Instance.new("Humanoid")
	humanoid.Name = "Humanoid"
	humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
	humanoid.Parent = model

	model.PrimaryPart = hrp

	-- Add BodyVelocity to control movement
	bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
	bodyVelocity.Velocity = Vector3.new(0,0,0)
	bodyVelocity.Parent = hrp

	return model
end

local function moveAnchor(dt)
	if not anchorModel or not anchorModel.PrimaryPart or not bodyVelocity then return end

	local direction = Vector3.new()

	local camCF = Camera.CFrame
	local lookVector = Vector3.new(camCF.LookVector.X, 0, camCF.LookVector.Z)
	if lookVector.Magnitude > 0 then
		lookVector = lookVector.Unit
	end
	local rightVector = Vector3.new(camCF.RightVector.X, 0, camCF.RightVector.Z)
	if rightVector.Magnitude > 0 then
		rightVector = rightVector.Unit
	end

	if keysPressed[Enum.KeyCode.W] then
		direction = direction + lookVector
	end
	if keysPressed[Enum.KeyCode.S] then
		direction = direction - lookVector
	end
	if keysPressed[Enum.KeyCode.A] then
		direction = direction - rightVector
	end
	if keysPressed[Enum.KeyCode.D] then
		direction = direction + rightVector
	end
	if keysPressed[Enum.KeyCode.Space] then
		direction = direction + Vector3.new(0, 1, 0)
	end
	if keysPressed[Enum.KeyCode.LeftControl] then
		direction = direction - Vector3.new(0, 1, 0)
	end

	if direction.Magnitude > 0 then
		bodyVelocity.Velocity = direction.Unit * moveSpeed
	else
		bodyVelocity.Velocity = Vector3.new(0,0,0)
	end
end

UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == Enum.KeyCode.Z then
		antiLockEnabled = not antiLockEnabled

		if antiLockEnabled then
			local char = LocalPlayer.Character
			if not char then return end
			local hrp = char:FindFirstChild("HumanoidRootPart")
			if not hrp then return end

			anchorModel = createAnchorModel(hrp.Position)

			-- Lock camera to the anchor model's HumanoidRootPart
			Camera.CameraSubject = anchorModel.PrimaryPart

			setNoclip(true)

			teleportLoop = RunService.Heartbeat:Connect(function(dt)
				moveAnchor(dt)

				-- Teleport your real character randomly around the anchor
				if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
					local offset = Vector3.new(
						math.random(-100, 100),
						math.random(-100, 100),
						math.random(-100, 100)
					)
					LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(anchorModel.PrimaryPart.Position + offset)
				end
			end)
		else
			if teleportLoop then
				teleportLoop:Disconnect()
				teleportLoop = nil
			end
			setNoclip(false)

			if anchorModel then
				-- Teleport your character to the anchor's last position before destroying
				if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
					LocalPlayer.Character.HumanoidRootPart.CFrame = anchorModel.PrimaryPart.CFrame
				end

				anchorModel:Destroy()
				anchorModel = nil
			end

			local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid")
			if humanoid then
				Camera.CameraSubject = humanoid
			end
		end
	end
end)
